\chapter{Scheduler events}
\label{ch:events_documentation}
%show /proc/PID/sched scheduling info
A simple script can give us the tracepoint location of every event that we are looking for.
\begin{codebash}
#!/bin/bash
# find_sched_events.sh
events=$(ls /sys/kernel/debug/tracing/events/sched | grep "sched_" | sort)
cd /path/to/linux-4.20.13
for i in $events
do
	grep -rin "trace_$i" >> ../events_output
done
\end{codebash}
This gives us the following output:
\begin{Verbatim}[xleftmargin=-2cm,fontsize=\footnotesize]
fs/exec.c:1698:		trace_sched_process_exec(current, old_pid, bprm);

kernel/exit.c:1503:	trace_sched_process_wait(wo->wo_pid);
kernel/exit.c:180:	trace_sched_process_free(tsk);
kernel/exit.c:866:	trace_sched_process_exit(tsk);

kernel/fork.c:2242:	trace_sched_process_fork(current, p);

kernel/hung_task.c:113:	trace_sched_process_hang(t);

kernel/kthread.c:543:	trace_sched_kthread_stop(k);
kernel/kthread.c:554:	trace_sched_kthread_stop_ret(ret);
kernel/kthread.c:554:	trace_sched_kthread_stop_ret(ret);

kernel/sched/core.c:1171:	trace_sched_migrate_task(p, new_cpu);
kernel/sched/core.c:1295:	trace_sched_swap_numa(cur, arg.src_cpu, p, arg.dst_cpu);
kernel/sched/core.c:1358:		trace_sched_wait_task(p);
kernel/sched/core.c:1659:	trace_sched_wakeup(p);
kernel/sched/core.c:1798:			trace_sched_wake_idle_without_ipi(cpu);
kernel/sched/core.c:1813:		trace_sched_wake_idle_without_ipi(cpu);
kernel/sched/core.c:473:		trace_sched_wake_idle_without_ipi(cpu);
kernel/sched/core.c:545:		trace_sched_wake_idle_without_ipi(cpu);
kernel/sched/core.c:1970:	trace_sched_waking(p);
kernel/sched/core.c:2100:	trace_sched_waking(p);
kernel/sched/core.c:2425:	trace_sched_wakeup_new(p);
kernel/sched/core.c:2425:	trace_sched_wakeup_new(p);
kernel/sched/core.c:3469:		trace_sched_switch(preempt, prev, next);
kernel/sched/core.c:3797:	trace_sched_pi_setprio(p, pi_task);
kernel/sched/core.c:5485:	trace_sched_move_numa(p, curr_cpu, target_cpu);

kernel/sched/fair.c:1836:			trace_sched_stick_numa(p, env.src_cpu, env.best_cpu);
kernel/sched/fair.c:1844:		trace_sched_stick_numa(p, env.src_cpu, task_cpu(env.best_task));
kernel/sched/fair.c:833:		trace_sched_stat_runtime(curtask, delta_exec, curr->vruntime);
kernel/sched/fair.c:886:		trace_sched_stat_wait(p, delta);
kernel/sched/fair.c:925:			trace_sched_stat_sleep(tsk, delta);
kernel/sched/fair.c:944:				trace_sched_stat_iowait(tsk, delta);
kernel/sched/fair.c:947:			trace_sched_stat_blocked(tsk, delta);
\end{Verbatim}

There are 24 events and 31 tracepoints.

\mycomment{MP: dove c'Ã¨ il tracepoint della exit ci sta un panic(). mostralo e citalo nel primo capitolo}

%ls /sys/kernel/debug/tracing/events/sched | grep "sched_" | wc -l
\section{Events in \texttt{core.c}} %MANCA UN EVENTO

\paragraph{\texttt{trace\_sched\_migrate\_task}}
\paragraph{\texttt{trace\_sched\_swap\_numa}}
\paragraph{\texttt{trace\_sched\_wait\_task}}
\paragraph{\texttt{trace\_sched\_wakeup}}
\paragraph{\texttt{trace\_sched\_wake\_idle\_without\_ipi}}
\paragraph{\texttt{trace\_sched\_waking}}
\paragraph{\texttt{trace\_sched\_wakeup\_new}}
\paragraph{\texttt{trace\_sched\_switch}}
\paragraph{\texttt{trace\_sched\_pi\_setprio}}
\paragraph{\texttt{trace\_sched\_move\_numa}}

\section{Events in \texttt{fair.c}}

\paragraph{\texttt{trace\_sched\_stick\_numa}}
\paragraph{\texttt{trace\_sched\_stat\_runtime}}
Mentioned in Chapter \ref{chap:ftrace}.
\paragraph{\texttt{trace\_sched\_stat\_wait}}
\paragraph{\texttt{trace\_sched\_stat\_sleep}}
\paragraph{\texttt{trace\_sched\_stat\_iowait}}
\paragraph{\texttt{trace\_sched\_stat\_blocked}}

\section{Events in other source files}

\paragraph{\texttt{trace\_sched\_process\_wait}}
\paragraph{\texttt{trace\_sched\_process\_free}}
\paragraph{\texttt{trace\_sched\_process\_exit}}
\paragraph{\texttt{trace\_sched\_process\_fork}}
\paragraph{\texttt{trace\_sched\_process\_hang}}
\paragraph{\texttt{trace\_sched\_kthread\_stop}}
\paragraph{\texttt{trace\_sched\_kthread\_stop\_ret}}

\section{Tracepoints reminder (will remove)} 

\begin{Verbatim}[xleftmargin=-2cm,fontsize=\footnotesize]
ifs:

kernel/sched/fair.c:3817:	if (trace_sched_stat_wait_enabled()    ||
kernel/sched/fair.c:3818:			trace_sched_stat_sleep_enabled()   ||
kernel/sched/fair.c:3819:			trace_sched_stat_iowait_enabled()  ||
kernel/sched/fair.c:3820:			trace_sched_stat_blocked_enabled() ||
kernel/sched/fair.c:3821:			trace_sched_stat_runtime_enabled())  {
\end{Verbatim}
Events details + comments found in the code
\begin{Verbatim}
/*
 * Tracepoint for calling kthread_stop, performed to end a kthread:
 */
sched_kthread_stop

/*
 * Tracepoint for the return value of the kthread stopping:
 */
sched_kthread_stop_ret

/*
 * Tracepoints for waking up a task:
 */

/*
 * Tracepoint called when waking a task; this tracepoint is guaranteed to be
 * called from the waking context.
 */
sched_waking:
  ./kernel/sched/core.c:1970:
    try_to_wake_up - wake up a thread
  ./kernel/sched/core.c:2100:
    try_to_wake_up_local - try to wake up a local task with rq lock held

/*
 * Tracepoint called when the task is actually woken; p->state == TASK_RUNNNG.
 * It it not always called from the waking context.
 */
sched_wakeup(./kernel/sched/core.c:1659):
  Mark the task runnable and perform wakeup-preemption.

/*
 * Tracepoint for waking up a new task:
 */
sched_wakeup_new(./kernel/sched/core.c:2425):
 wake_up_new_task - wake up a newly created task for the first time.
   This function will do some initial scheduler statistics housekeeping
   that must be done for every newly created context, then puts the task
   on the runqueue and wakes it.

/*
 * Tracepoint for task switches, performed by the scheduler:
 */
sched_switch(./kernel/sched/core.c:3469):
  context_switch - switch to the new MM and the new thread's register state.

/*
 * Tracepoint for a task being migrated:
 */
sched_migrate_task(./kernel/sched/core.c:1171):
  set_task_cpu(struct task_struct *p, unsigned int new_cpu)
  Migrate a task to new_cpu.

/*
 * Tracepoint for freeing a task:
 */
sched_process_free(./kernel/exit.c:180):
  TODO

/*
 * Tracepoint for a task exiting:
 */
sched_process_exit(./kernel/exit.c:866):
  process exit

/*
 * Tracepoint for waiting on task to unschedule:
 */
sched_wait_task

/*
 * Tracepoint for a waiting task:
 */
sched_process_wait(./kernel/exit.c:1503):

/*
 * Tracepoint for do_fork:
 */
sched_process_fork: (./kernel/fork.c:2242)
  _do_fork
    It copies the process, and if successful kick-starts                                                                                                   
    it and waits for it to finish using the VM if required.

/*
 * Tracepoint for exec:
 */
sched_process_exec(./fs/exec.c:1698):
  exec_binprm(struct linux_binprm *bprm)
  load binaries using bprm(binary parameter)

/*
 * Tracepoint for accounting wait time (time the task is runnable
 * but not actually running due to scheduler contention).
 */
sched_stat_wait

/*
 * Tracepoint for accounting sleep time (time the task is not runnable,
 * including iowait, see below).
 */
sched_stat_sleep

/*
 * Tracepoint for accounting iowait time (time the task is not runnable
 * due to waiting on IO to complete).
 */
sched_stat_iowait

/*
 * Tracepoint for accounting blocked time (time the task is in uninterruptible).
 */
sched_stat_blocked

/*
 * Tracepoint for accounting runtime (time the task is executing
 * on a CPU).
 */
sched_stat_runtime(./kernel/sched/fair.c:829):
  Update the current task's runtime statistics.

/*
 * Tracepoint for showing priority inheritance modifying a tasks
 * priority.
 */
sched_pi_setprio

/*
 * Detect Hung Task
 */
sched_process_hang(./kernel/hung_task.c:113):
  Kernel thread for detecting tasks stuck in D state

/*
 * Tracks migration of tasks from one runqueue to another. Can be used to
 * detect if automatic NUMA balancing is bouncing between nodes
 */
sched_move_numa

//TODO
sched_stick_numa

//TODO
sched_swap_numa

/*
 * Tracepoint for waking a polling cpu without an IPI.
 */
sched_wake_idle_without_ipi
\end{Verbatim}